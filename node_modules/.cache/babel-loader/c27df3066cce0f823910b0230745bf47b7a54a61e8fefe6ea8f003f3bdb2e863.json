{"ast":null,"code":"'use strict';\n\nvar util = require('util');\nvar fs = require('graceful-fs');\nvar assign = require('object.assign');\nvar date = require('value-or-function').date;\nvar Writable = require('readable-stream').Writable;\nvar constants = require('./constants');\nvar APPEND_MODE_REGEXP = /a/;\nfunction closeFd(propagatedErr, fd, callback) {\n  if (typeof fd !== 'number') {\n    return callback(propagatedErr);\n  }\n  fs.close(fd, onClosed);\n  function onClosed(closeErr) {\n    if (propagatedErr || closeErr) {\n      return callback(propagatedErr || closeErr);\n    }\n    callback();\n  }\n}\nfunction isValidUnixId(id) {\n  if (typeof id !== 'number') {\n    return false;\n  }\n  if (id < 0) {\n    return false;\n  }\n  return true;\n}\nfunction getFlags(options) {\n  var flags = !options.append ? 'w' : 'a';\n  if (!options.overwrite) {\n    flags += 'x';\n  }\n  return flags;\n}\nfunction isFatalOverwriteError(err, flags) {\n  if (!err) {\n    return false;\n  }\n  if (err.code === 'EEXIST' && flags[1] === 'x') {\n    // Handle scenario for file overwrite failures.\n    return false;\n  }\n\n  // Otherwise, this is a fatal error\n  return true;\n}\nfunction isFatalUnlinkError(err) {\n  if (!err || err.code === 'ENOENT') {\n    return false;\n  }\n  return true;\n}\nfunction getModeDiff(fsMode, vinylMode) {\n  var modeDiff = 0;\n  if (typeof vinylMode === 'number') {\n    modeDiff = (vinylMode ^ fsMode) & constants.MASK_MODE;\n  }\n  return modeDiff;\n}\nfunction getTimesDiff(fsStat, vinylStat) {\n  var mtime = date(vinylStat.mtime) || 0;\n  if (!mtime) {\n    return;\n  }\n  var atime = date(vinylStat.atime) || 0;\n  if (+mtime === +fsStat.mtime && +atime === +fsStat.atime) {\n    return;\n  }\n  if (!atime) {\n    atime = date(fsStat.atime) || undefined;\n  }\n  var timesDiff = {\n    mtime: vinylStat.mtime,\n    atime: atime\n  };\n  return timesDiff;\n}\nfunction getOwnerDiff(fsStat, vinylStat) {\n  if (!isValidUnixId(vinylStat.uid) && !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n  if (!isValidUnixId(fsStat.uid) && !isValidUnixId(vinylStat.uid) || !isValidUnixId(fsStat.gid) && !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n  var uid = fsStat.uid; // Default to current uid.\n  if (isValidUnixId(vinylStat.uid)) {\n    uid = vinylStat.uid;\n  }\n  var gid = fsStat.gid; // Default to current gid.\n  if (isValidUnixId(vinylStat.gid)) {\n    gid = vinylStat.gid;\n  }\n  if (uid === fsStat.uid && gid === fsStat.gid) {\n    return;\n  }\n  var ownerDiff = {\n    uid: uid,\n    gid: gid\n  };\n  return ownerDiff;\n}\nfunction isOwner(fsStat) {\n  var hasGetuid = typeof process.getuid === 'function';\n  var hasGeteuid = typeof process.geteuid === 'function';\n\n  // If we don't have either, assume we don't have permissions.\n  // This should only happen on Windows.\n  // Windows basically noops fchmod and errors on futimes called on directories.\n  if (!hasGeteuid && !hasGetuid) {\n    return false;\n  }\n  var uid;\n  if (hasGeteuid) {\n    uid = process.geteuid();\n  } else {\n    uid = process.getuid();\n  }\n  if (fsStat.uid !== uid && uid !== 0) {\n    return false;\n  }\n  return true;\n}\nfunction reflectStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.stat(path, onStat);\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n    file.stat = stat;\n    callback();\n  }\n}\nfunction reflectLinkStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.lstat(path, onLstat);\n  function onLstat(lstatErr, stat) {\n    if (lstatErr) {\n      return callback(lstatErr);\n    }\n    file.stat = stat;\n    callback();\n  }\n}\nfunction updateMetadata(fd, file, callback) {\n  fs.fstat(fd, onStat);\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n\n    // Check if mode needs to be updated\n    var modeDiff = getModeDiff(stat.mode, file.stat.mode);\n\n    // Check if atime/mtime need to be updated\n    var timesDiff = getTimesDiff(stat, file.stat);\n\n    // Check if uid/gid need to be updated\n    var ownerDiff = getOwnerDiff(stat, file.stat);\n\n    // Set file.stat to the reflect current state on disk\n    assign(file.stat, stat);\n\n    // Nothing to do\n    if (!modeDiff && !timesDiff && !ownerDiff) {\n      return callback();\n    }\n\n    // Check access, `futimes`, `fchmod` & `fchown` only work if we own\n    // the file, or if we are effectively root (`fchown` only when root).\n    if (!isOwner(stat)) {\n      return callback();\n    }\n    if (modeDiff) {\n      return mode();\n    }\n    if (timesDiff) {\n      return times();\n    }\n    owner();\n    function mode() {\n      var mode = stat.mode ^ modeDiff;\n      fs.fchmod(fd, mode, onFchmod);\n      function onFchmod(fchmodErr) {\n        if (!fchmodErr) {\n          file.stat.mode = mode;\n        }\n        if (timesDiff) {\n          return times(fchmodErr);\n        }\n        if (ownerDiff) {\n          return owner(fchmodErr);\n        }\n        callback(fchmodErr);\n      }\n    }\n    function times(propagatedErr) {\n      fs.futimes(fd, timesDiff.atime, timesDiff.mtime, onFutimes);\n      function onFutimes(futimesErr) {\n        if (!futimesErr) {\n          file.stat.atime = timesDiff.atime;\n          file.stat.mtime = timesDiff.mtime;\n        }\n        if (ownerDiff) {\n          return owner(propagatedErr || futimesErr);\n        }\n        callback(propagatedErr || futimesErr);\n      }\n    }\n    function owner(propagatedErr) {\n      fs.fchown(fd, ownerDiff.uid, ownerDiff.gid, onFchown);\n      function onFchown(fchownErr) {\n        if (!fchownErr) {\n          file.stat.uid = ownerDiff.uid;\n          file.stat.gid = ownerDiff.gid;\n        }\n        callback(propagatedErr || fchownErr);\n      }\n    }\n  }\n}\nfunction symlink(srcPath, destPath, opts, callback) {\n  // Because fs.symlink does not allow atomic overwrite option with flags, we\n  // delete and recreate if the link already exists and overwrite is true.\n  if (opts.flags === 'w') {\n    // TODO What happens when we call unlink with windows junctions?\n    fs.unlink(destPath, onUnlink);\n  } else {\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n  function onUnlink(unlinkErr) {\n    if (isFatalUnlinkError(unlinkErr)) {\n      return callback(unlinkErr);\n    }\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n  function onSymlink(symlinkErr) {\n    if (isFatalOverwriteError(symlinkErr, opts.flags)) {\n      return callback(symlinkErr);\n    }\n    callback();\n  }\n}\n\n/*\n  Custom writeFile implementation because we need access to the\n  file descriptor after the write is complete.\n  Most of the implementation taken from node core.\n */\nfunction writeFile(filepath, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (!Buffer.isBuffer(data)) {\n    return callback(new TypeError('Data must be a Buffer'));\n  }\n  if (!options) {\n    options = {};\n  }\n\n  // Default the same as node\n  var mode = options.mode || constants.DEFAULT_FILE_MODE;\n  var flags = options.flags || 'w';\n  var position = APPEND_MODE_REGEXP.test(flags) ? null : 0;\n  fs.open(filepath, flags, mode, onOpen);\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      return onComplete(openErr);\n    }\n    fs.write(fd, data, 0, data.length, position, onComplete);\n    function onComplete(writeErr) {\n      callback(writeErr, fd);\n    }\n  }\n}\nfunction createWriteStream(path, options, flush) {\n  return new WriteStream(path, options, flush);\n}\n\n// Taken from node core and altered to receive a flush function and simplified\n// To be used for cleanup (like updating times/mode/etc)\nfunction WriteStream(path, options, flush) {\n  // Not exposed so we can avoid the case where someone doesn't use `new`\n\n  if (typeof options === 'function') {\n    flush = options;\n    options = null;\n  }\n  options = options || {};\n  Writable.call(this, options);\n  this.flush = flush;\n  this.path = path;\n  this.mode = options.mode || constants.DEFAULT_FILE_MODE;\n  this.flags = options.flags || 'w';\n\n  // Used by node's `fs.WriteStream`\n  this.fd = null;\n  this.start = null;\n  this.open();\n\n  // Dispose on finish.\n  this.once('finish', this.close);\n}\nutil.inherits(WriteStream, Writable);\nWriteStream.prototype.open = function () {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, onOpen);\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      self.destroy();\n      self.emit('error', openErr);\n      return;\n    }\n    self.fd = fd;\n    self.emit('open', fd);\n  }\n};\n\n// Use our `end` method since it is patched for flush\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\nWriteStream.prototype._destroy = function (err, cb) {\n  this.close(function (err2) {\n    cb(err || err2);\n  });\n};\nWriteStream.prototype.close = function (cb) {\n  var that = this;\n  if (cb) {\n    this.once('close', cb);\n  }\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', closeOnOpen);\n      return;\n    }\n    return process.nextTick(function () {\n      that.emit('close');\n    });\n  }\n  this.closed = true;\n  fs.close(this.fd, function (er) {\n    if (er) {\n      that.emit('error', er);\n    } else {\n      that.emit('close');\n    }\n  });\n  this.fd = null;\n};\nWriteStream.prototype._final = function (callback) {\n  if (typeof this.flush !== 'function') {\n    return callback();\n  }\n  this.flush(this.fd, callback);\n};\nfunction closeOnOpen() {\n  this.close();\n}\nWriteStream.prototype._write = function (data, encoding, callback) {\n  var self = this;\n\n  // This is from node core but I have no idea how to get code coverage on it\n  if (!Buffer.isBuffer(data)) {\n    return this.emit('error', new Error('Invalid data'));\n  }\n  if (typeof this.fd !== 'number') {\n    return this.once('open', onOpen);\n  }\n  fs.write(this.fd, data, 0, data.length, null, onWrite);\n  function onOpen() {\n    self._write(data, encoding, callback);\n  }\n  function onWrite(writeErr) {\n    if (writeErr) {\n      self.destroy();\n      callback(writeErr);\n      return;\n    }\n    callback();\n  }\n};\nmodule.exports = {\n  closeFd: closeFd,\n  isValidUnixId: isValidUnixId,\n  getFlags: getFlags,\n  isFatalOverwriteError: isFatalOverwriteError,\n  isFatalUnlinkError: isFatalUnlinkError,\n  getModeDiff: getModeDiff,\n  getTimesDiff: getTimesDiff,\n  getOwnerDiff: getOwnerDiff,\n  isOwner: isOwner,\n  reflectStat: reflectStat,\n  reflectLinkStat: reflectLinkStat,\n  updateMetadata: updateMetadata,\n  symlink: symlink,\n  writeFile: writeFile,\n  createWriteStream: createWriteStream\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}