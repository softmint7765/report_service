{"ast":null,"code":"'use strict';\n\nvar PassThrough = require('readable-stream').PassThrough;\nvar inherits = require('inherits');\nvar p = require('process-nextick-args');\nfunction Cloneable(stream, opts) {\n  if (!(this instanceof Cloneable)) {\n    return new Cloneable(stream, opts);\n  }\n  var objectMode = stream._readableState.objectMode;\n  this._original = stream;\n  this._clonesCount = 1;\n  opts = opts || {};\n  opts.objectMode = objectMode;\n  PassThrough.call(this, opts);\n  forwardDestroy(stream, this);\n  this.on('newListener', onData);\n  this.once('resume', onResume);\n  this._hasListener = true;\n}\ninherits(Cloneable, PassThrough);\nfunction onData(event, listener) {\n  if (event === 'data' || event === 'readable') {\n    this._hasListener = false;\n    this.removeListener('newListener', onData);\n    this.removeListener('resume', onResume);\n    p.nextTick(clonePiped, this);\n  }\n}\nfunction onResume() {\n  this._hasListener = false;\n  this.removeListener('newListener', onData);\n  p.nextTick(clonePiped, this);\n}\nCloneable.prototype.clone = function () {\n  if (!this._original) {\n    throw new Error('already started');\n  }\n  this._clonesCount++;\n\n  // the events added by the clone should not count\n  // for starting the flow\n  this.removeListener('newListener', onData);\n  var clone = new Clone(this);\n  if (this._hasListener) {\n    this.on('newListener', onData);\n  }\n  return clone;\n};\nCloneable.prototype._destroy = function (err, cb) {\n  if (!err) {\n    this.push(null);\n    this.end();\n    this.emit('close');\n  }\n  p.nextTick(cb, err);\n};\nfunction forwardDestroy(src, dest) {\n  src.on('error', destroy);\n  src.on('close', onClose);\n  function destroy(err) {\n    src.removeListener('close', onClose);\n    dest.destroy(err);\n  }\n  function onClose() {\n    dest.end();\n  }\n}\nfunction clonePiped(that) {\n  if (--that._clonesCount === 0 && !that._readableState.destroyed) {\n    that._original.pipe(that);\n    that._original = undefined;\n  }\n}\nfunction Clone(parent, opts) {\n  if (!(this instanceof Clone)) {\n    return new Clone(parent, opts);\n  }\n  var objectMode = parent._readableState.objectMode;\n  opts = opts || {};\n  opts.objectMode = objectMode;\n  this.parent = parent;\n  PassThrough.call(this, opts);\n  forwardDestroy(parent, this);\n  parent.pipe(this);\n\n  // the events added by the clone should not count\n  // for starting the flow\n  // so we add the newListener handle after we are done\n  this.on('newListener', onDataClone);\n  this.on('resume', onResumeClone);\n}\nfunction onDataClone(event, listener) {\n  // We start the flow once all clones are piped or destroyed\n  if (event === 'data' || event === 'readable' || event === 'close') {\n    p.nextTick(clonePiped, this.parent);\n    this.removeListener('newListener', onDataClone);\n  }\n}\nfunction onResumeClone() {\n  this.removeListener('newListener', onDataClone);\n  p.nextTick(clonePiped, this.parent);\n}\ninherits(Clone, PassThrough);\nClone.prototype.clone = function () {\n  return this.parent.clone();\n};\nCloneable.isCloneable = function (stream) {\n  return stream instanceof Cloneable || stream instanceof Clone;\n};\nClone.prototype._destroy = function (err, cb) {\n  if (!err) {\n    this.push(null);\n    this.end();\n    this.emit('close');\n  }\n  p.nextTick(cb, err);\n};\nmodule.exports = Cloneable;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}