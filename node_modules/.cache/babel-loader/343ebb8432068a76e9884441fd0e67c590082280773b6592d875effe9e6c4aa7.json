{"ast":null,"code":"var util = require('./util');\nvar types = require('./types');\nvar sets = require('./sets');\nvar positions = require('./positions');\nmodule.exports = function (regexpStr) {\n  var i = 0,\n    l,\n    c,\n    start = {\n      type: types.ROOT,\n      stack: []\n    },\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n  var repeatErr = function repeatErr(i) {\n    util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n          case 'w':\n            last.push(sets.words());\n            break;\n          case 'W':\n            last.push(sets.notWords());\n            break;\n          case 'd':\n            last.push(sets.ints());\n            break;\n          case 'D':\n            last.push(sets.notInts());\n            break;\n          case 's':\n            last.push(sets.whitespace());\n            break;\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({\n                type: types.REFERENCE,\n                value: parseInt(c, 10)\n              });\n\n              // Escaped character.\n            } else {\n              last.push({\n                type: types.CHAR,\n                value: c.charCodeAt(0)\n              });\n            }\n        }\n        break;\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n      case '$':\n        last.push(positions.end());\n        break;\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not: not\n        });\n        break;\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true\n        };\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n            // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n          } else if (c !== ':') {\n            util.error(regexpStr, 'Invalid group, character \\'' + c + '\\' after \\'?\\' at column ' + (i - 1));\n          }\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)),\n          min,\n          max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n          last.push({\n            type: types.REPETITION,\n            min: min,\n            max: max,\n            value: last.pop()\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123\n          });\n        }\n        break;\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop()\n        });\n        break;\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop()\n        });\n        break;\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop()\n        });\n        break;\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0)\n        });\n    }\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n  return start;\n};\nmodule.exports.types = types;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}