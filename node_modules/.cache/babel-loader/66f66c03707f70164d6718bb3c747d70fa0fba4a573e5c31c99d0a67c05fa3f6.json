{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar util = require('util');\nvar isBuffer = require('buffer').Buffer.isBuffer;\nvar clone = require('clone');\nvar cloneable = require('cloneable-readable');\nvar replaceExt = require('replace-ext');\nvar cloneStats = require('clone-stats');\nvar cloneBuffer = require('clone-buffer');\nvar removeTrailingSep = require('remove-trailing-separator');\nvar isStream = require('./lib/is-stream');\nvar normalize = require('./lib/normalize');\nvar inspectStream = require('./lib/inspect-stream');\nvar builtInFields = ['_contents', '_symlink', 'contents', 'stat', 'history', 'path', '_base', 'base', '_cwd', 'cwd'];\nfunction File(file) {\n  var self = this;\n  if (!file) {\n    file = {};\n  }\n\n  // Stat = files stats object\n  this.stat = file.stat || null;\n\n  // Contents = stream, buffer, or null if not read\n  this.contents = file.contents || null;\n\n  // Replay path history to ensure proper normalization and trailing sep\n  var history = Array.prototype.slice.call(file.history || []);\n  if (file.path) {\n    history.push(file.path);\n  }\n  this.history = [];\n  history.forEach(function (path) {\n    self.path = path;\n  });\n  this.cwd = file.cwd || process.cwd();\n  this.base = file.base;\n  this._isVinyl = true;\n  this._symlink = null;\n\n  // Set custom properties\n  Object.keys(file).forEach(function (key) {\n    if (self.constructor.isCustomProp(key)) {\n      self[key] = file[key];\n    }\n  });\n}\nFile.prototype.isBuffer = function () {\n  return isBuffer(this.contents);\n};\nFile.prototype.isStream = function () {\n  return isStream(this.contents);\n};\nFile.prototype.isNull = function () {\n  return this.contents === null;\n};\nFile.prototype.isDirectory = function () {\n  if (!this.isNull()) {\n    return false;\n  }\n  if (this.stat && typeof this.stat.isDirectory === 'function') {\n    return this.stat.isDirectory();\n  }\n  return false;\n};\nFile.prototype.isSymbolic = function () {\n  if (!this.isNull()) {\n    return false;\n  }\n  if (this.stat && typeof this.stat.isSymbolicLink === 'function') {\n    return this.stat.isSymbolicLink();\n  }\n  return false;\n};\nFile.prototype.clone = function (opt) {\n  var self = this;\n  if (typeof opt === 'boolean') {\n    opt = {\n      deep: opt,\n      contents: true\n    };\n  } else if (!opt) {\n    opt = {\n      deep: true,\n      contents: true\n    };\n  } else {\n    opt.deep = opt.deep === true;\n    opt.contents = opt.contents !== false;\n  }\n\n  // Clone our file contents\n  var contents;\n  if (this.isStream()) {\n    contents = this.contents.clone();\n  } else if (this.isBuffer()) {\n    contents = opt.contents ? cloneBuffer(this.contents) : this.contents;\n  }\n  var file = new this.constructor({\n    cwd: this.cwd,\n    base: this.base,\n    stat: this.stat ? cloneStats(this.stat) : null,\n    history: this.history.slice(),\n    contents: contents\n  });\n  if (this.isSymbolic()) {\n    file.symlink = this.symlink;\n  }\n\n  // Clone our custom properties\n  Object.keys(this).forEach(function (key) {\n    if (self.constructor.isCustomProp(key)) {\n      file[key] = opt.deep ? clone(self[key], true) : self[key];\n    }\n  });\n  return file;\n};\nFile.prototype.inspect = function () {\n  var inspect = [];\n\n  // Use relative path if possible\n  var filePath = this.path ? this.relative : null;\n  if (filePath) {\n    inspect.push('\"' + filePath + '\"');\n  }\n  if (this.isBuffer()) {\n    inspect.push(this.contents.inspect());\n  }\n  if (this.isStream()) {\n    inspect.push(inspectStream(this.contents));\n  }\n  return '<File ' + inspect.join(' ') + '>';\n};\n\n// Newer Node.js versions use this symbol for custom inspection.\nif (util.inspect.custom) {\n  File.prototype[util.inspect.custom] = File.prototype.inspect;\n}\nFile.isCustomProp = function (key) {\n  return builtInFields.indexOf(key) === -1;\n};\nFile.isVinyl = function (file) {\n  return file && file._isVinyl === true || false;\n};\n\n// Virtual attributes\n// Or stuff with extra logic\nObject.defineProperty(File.prototype, 'contents', {\n  get: function get() {\n    return this._contents;\n  },\n  set: function set(val) {\n    if (!isBuffer(val) && !isStream(val) && val !== null) {\n      throw new Error('File.contents can only be a Buffer, a Stream, or null.');\n    }\n\n    // Ask cloneable if the stream is a already a cloneable\n    // this avoid piping into many streams\n    // reducing the overhead of cloning\n    if (isStream(val) && !cloneable.isCloneable(val)) {\n      val = cloneable(val);\n    }\n    this._contents = val;\n  }\n});\nObject.defineProperty(File.prototype, 'cwd', {\n  get: function get() {\n    return this._cwd;\n  },\n  set: function set(cwd) {\n    if (!cwd || typeof cwd !== 'string') {\n      throw new Error('cwd must be a non-empty string.');\n    }\n    this._cwd = removeTrailingSep(normalize(cwd));\n  }\n});\nObject.defineProperty(File.prototype, 'base', {\n  get: function get() {\n    return this._base || this._cwd;\n  },\n  set: function set(base) {\n    if (base == null) {\n      delete this._base;\n      return;\n    }\n    if (typeof base !== 'string' || !base) {\n      throw new Error('base must be a non-empty string, or null/undefined.');\n    }\n    base = removeTrailingSep(normalize(base));\n    if (base !== this._cwd) {\n      this._base = base;\n    } else {\n      delete this._base;\n    }\n  }\n});\n\n// TODO: Should this be moved to vinyl-fs?\nObject.defineProperty(File.prototype, 'relative', {\n  get: function get() {\n    if (!this.path) {\n      throw new Error('No path specified! Can not get relative.');\n    }\n    return path.relative(this.base, this.path);\n  },\n  set: function set() {\n    throw new Error('File.relative is generated from the base and path attributes. Do not modify it.');\n  }\n});\nObject.defineProperty(File.prototype, 'dirname', {\n  get: function get() {\n    if (!this.path) {\n      throw new Error('No path specified! Can not get dirname.');\n    }\n    return path.dirname(this.path);\n  },\n  set: function set(dirname) {\n    if (!this.path) {\n      throw new Error('No path specified! Can not set dirname.');\n    }\n    this.path = path.join(dirname, this.basename);\n  }\n});\nObject.defineProperty(File.prototype, 'basename', {\n  get: function get() {\n    if (!this.path) {\n      throw new Error('No path specified! Can not get basename.');\n    }\n    return path.basename(this.path);\n  },\n  set: function set(basename) {\n    if (!this.path) {\n      throw new Error('No path specified! Can not set basename.');\n    }\n    this.path = path.join(this.dirname, basename);\n  }\n});\n\n// Property for getting/setting stem of the filename.\nObject.defineProperty(File.prototype, 'stem', {\n  get: function get() {\n    if (!this.path) {\n      throw new Error('No path specified! Can not get stem.');\n    }\n    return path.basename(this.path, this.extname);\n  },\n  set: function set(stem) {\n    if (!this.path) {\n      throw new Error('No path specified! Can not set stem.');\n    }\n    this.path = path.join(this.dirname, stem + this.extname);\n  }\n});\nObject.defineProperty(File.prototype, 'extname', {\n  get: function get() {\n    if (!this.path) {\n      throw new Error('No path specified! Can not get extname.');\n    }\n    return path.extname(this.path);\n  },\n  set: function set(extname) {\n    if (!this.path) {\n      throw new Error('No path specified! Can not set extname.');\n    }\n    this.path = replaceExt(this.path, extname);\n  }\n});\nObject.defineProperty(File.prototype, 'path', {\n  get: function get() {\n    return this.history[this.history.length - 1];\n  },\n  set: function set(path) {\n    if (typeof path !== 'string') {\n      throw new Error('path should be a string.');\n    }\n    path = removeTrailingSep(normalize(path));\n\n    // Record history only when path changed\n    if (path && path !== this.path) {\n      this.history.push(path);\n    }\n  }\n});\nObject.defineProperty(File.prototype, 'symlink', {\n  get: function get() {\n    return this._symlink;\n  },\n  set: function set(symlink) {\n    // TODO: should this set the mode to symbolic if set?\n    if (typeof symlink !== 'string') {\n      throw new Error('symlink should be a string');\n    }\n    this._symlink = removeTrailingSep(normalize(symlink));\n  }\n});\nmodule.exports = File;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}