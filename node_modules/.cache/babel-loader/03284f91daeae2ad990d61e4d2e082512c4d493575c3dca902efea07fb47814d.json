{"ast":null,"code":"'use strict';\n\nvar Combine = require('ordered-read-streams');\nvar unique = require('unique-stream');\nvar pumpify = require('pumpify');\nvar isNegatedGlob = require('is-negated-glob');\nvar extend = require('extend');\nvar GlobStream = require('./readable');\nfunction globStream(globs, opt) {\n  if (!opt) {\n    opt = {};\n  }\n  var ourOpt = extend({}, opt);\n  var ignore = ourOpt.ignore;\n  ourOpt.cwd = typeof ourOpt.cwd === 'string' ? ourOpt.cwd : process.cwd();\n  ourOpt.dot = typeof ourOpt.dot === 'boolean' ? ourOpt.dot : false;\n  ourOpt.silent = typeof ourOpt.silent === 'boolean' ? ourOpt.silent : true;\n  ourOpt.cwdbase = typeof ourOpt.cwdbase === 'boolean' ? ourOpt.cwdbase : false;\n  ourOpt.uniqueBy = typeof ourOpt.uniqueBy === 'string' || typeof ourOpt.uniqueBy === 'function' ? ourOpt.uniqueBy : 'path';\n  if (ourOpt.cwdbase) {\n    ourOpt.base = ourOpt.cwd;\n  }\n  // Normalize string `ignore` to array\n  if (typeof ignore === 'string') {\n    ignore = [ignore];\n  }\n  // Ensure `ignore` is an array\n  if (!Array.isArray(ignore)) {\n    ignore = [];\n  }\n\n  // Only one glob no need to aggregate\n  if (!Array.isArray(globs)) {\n    globs = [globs];\n  }\n  var positives = [];\n  var negatives = [];\n  globs.forEach(sortGlobs);\n  function sortGlobs(globString, index) {\n    if (typeof globString !== 'string') {\n      throw new Error('Invalid glob at index ' + index);\n    }\n    var glob = isNegatedGlob(globString);\n    var globArray = glob.negated ? negatives : positives;\n    globArray.push({\n      index: index,\n      glob: glob.pattern\n    });\n  }\n  if (positives.length === 0) {\n    throw new Error('Missing positive glob');\n  }\n\n  // Create all individual streams\n  var streams = positives.map(streamFromPositive);\n\n  // Then just pipe them to a single unique stream and return it\n  var aggregate = new Combine(streams);\n  var uniqueStream = unique(ourOpt.uniqueBy);\n  return pumpify.obj(aggregate, uniqueStream);\n  function streamFromPositive(positive) {\n    var negativeGlobs = negatives.filter(indexGreaterThan(positive.index)).map(toGlob).concat(ignore);\n    return new GlobStream(positive.glob, negativeGlobs, ourOpt);\n  }\n}\nfunction indexGreaterThan(index) {\n  return function (obj) {\n    return obj.index > index;\n  };\n}\nfunction toGlob(obj) {\n  return obj.glob;\n}\nmodule.exports = globStream;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}