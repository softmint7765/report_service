{"ast":null,"code":"// Note: source-map-resolve.js is generated from source-map-resolve-node.js and\n// source-map-resolve-template.js. Only edit the two latter files, _not_\n// source-map-resolve.js!\n\nvoid function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"source-map-url\", \"resolve-url\"], factory);\n  } else if (typeof exports === \"object\") {\n    var sourceMappingURL = require(\"source-map-url\");\n    var resolveUrl = require(\"resolve-url\");\n    module.exports = factory(sourceMappingURL, resolveUrl);\n  } else {\n    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl);\n  }\n}(this, function (sourceMappingURL, resolveUrl) {\n  function callbackAsync(callback, error, result) {\n    setImmediate(function () {\n      callback(error, result);\n    });\n  }\n  function parseMapToJSON(string, data) {\n    try {\n      return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"));\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n  }\n  function readSync(read, url, data) {\n    var readUrl = url;\n    try {\n      return String(read(readUrl));\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n  }\n  function resolveSourceMap(code, codeUrl, read, callback) {\n    var mapData;\n    try {\n      mapData = resolveSourceMapHelper(code, codeUrl);\n    } catch (error) {\n      return callbackAsync(callback, error);\n    }\n    if (!mapData || mapData.map) {\n      return callbackAsync(callback, null, mapData);\n    }\n    var readUrl = mapData.url;\n    read(readUrl, function (error, result) {\n      if (error) {\n        error.sourceMapData = mapData;\n        return callback(error);\n      }\n      mapData.map = String(result);\n      try {\n        mapData.map = parseMapToJSON(mapData.map, mapData);\n      } catch (error) {\n        return callback(error);\n      }\n      callback(null, mapData);\n    });\n  }\n  function resolveSourceMapSync(code, codeUrl, read) {\n    var mapData = resolveSourceMapHelper(code, codeUrl);\n    if (!mapData || mapData.map) {\n      return mapData;\n    }\n    mapData.map = readSync(read, mapData.url, mapData);\n    mapData.map = parseMapToJSON(mapData.map, mapData);\n    return mapData;\n  }\n  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;\n\n  /**\n   * The media type for JSON text is application/json.\n   *\n   * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n   *\n   * `text/json` is non-standard media type\n   */\n  var jsonMimeTypeRegex = /^(?:application|text)\\/json$/;\n\n  /**\n   * JSON text exchanged between systems that are not part of a closed ecosystem\n   * MUST be encoded using UTF-8.\n   *\n   * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n   */\n  var jsonCharacterEncoding = \"utf-8\";\n  function base64ToBuf(b64) {\n    var binStr = atob(b64);\n    var len = binStr.length;\n    var arr = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n      arr[i] = binStr.charCodeAt(i);\n    }\n    return arr;\n  }\n  function decodeBase64String(b64) {\n    if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n      return atob(b64);\n    }\n    var buf = base64ToBuf(b64);\n    // Note: `decoder.decode` method will throw a `DOMException` with the\n    // `\"EncodingError\"` value when an coding error is found.\n    var decoder = new TextDecoder(jsonCharacterEncoding, {\n      fatal: true\n    });\n    return decoder.decode(buf);\n  }\n  function resolveSourceMapHelper(code, codeUrl) {\n    var url = sourceMappingURL.getFrom(code);\n    if (!url) {\n      return null;\n    }\n    var dataUri = url.match(dataUriRegex);\n    if (dataUri) {\n      var mimeType = dataUri[1] || \"text/plain\";\n      var lastParameter = dataUri[2] || \"\";\n      var encoded = dataUri[3] || \"\";\n      var data = {\n        sourceMappingURL: url,\n        url: null,\n        sourcesRelativeTo: codeUrl,\n        map: encoded\n      };\n      if (!jsonMimeTypeRegex.test(mimeType)) {\n        var error = new Error(\"Unuseful data uri mime type: \" + mimeType);\n        error.sourceMapData = data;\n        throw error;\n      }\n      try {\n        data.map = parseMapToJSON(lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);\n      } catch (error) {\n        error.sourceMapData = data;\n        throw error;\n      }\n      return data;\n    }\n    var mapUrl = resolveUrl(codeUrl, url);\n    return {\n      sourceMappingURL: url,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n  }\n  function resolveSources(map, mapUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n    var pending = map.sources ? map.sources.length : 0;\n    var result = {\n      sourcesResolved: [],\n      sourcesContent: []\n    };\n    if (pending === 0) {\n      callbackAsync(callback, null, result);\n      return;\n    }\n    var done = function done() {\n      pending--;\n      if (pending === 0) {\n        callback(null, result);\n      }\n    };\n    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl;\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent;\n        callbackAsync(done, null);\n      } else {\n        var readUrl = fullUrl;\n        read(readUrl, function (error, source) {\n          result.sourcesContent[index] = error ? error : String(source);\n          done();\n        });\n      }\n    });\n  }\n  function resolveSourcesSync(map, mapUrl, read, options) {\n    var result = {\n      sourcesResolved: [],\n      sourcesContent: []\n    };\n    if (!map.sources || map.sources.length === 0) {\n      return result;\n    }\n    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl;\n      if (read !== null) {\n        if (typeof sourceContent === \"string\") {\n          result.sourcesContent[index] = sourceContent;\n        } else {\n          var readUrl = fullUrl;\n          try {\n            result.sourcesContent[index] = String(read(readUrl));\n          } catch (error) {\n            result.sourcesContent[index] = error;\n          }\n        }\n      }\n    });\n    return result;\n  }\n  var endingSlash = /\\/?$/;\n  function resolveSourcesHelper(map, mapUrl, options, fn) {\n    options = options || {};\n    var fullUrl;\n    var sourceContent;\n    var sourceRoot;\n    for (var index = 0, len = map.sources.length; index < len; index++) {\n      sourceRoot = null;\n      if (typeof options.sourceRoot === \"string\") {\n        sourceRoot = options.sourceRoot;\n      } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n        sourceRoot = map.sourceRoot;\n      }\n      // If the sourceRoot is the empty string, it is equivalent to not setting\n      // the property at all.\n      if (sourceRoot === null || sourceRoot === '') {\n        fullUrl = resolveUrl(mapUrl, map.sources[index]);\n      } else {\n        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n        // does not make sense.\n        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index]);\n      }\n      sourceContent = (map.sourcesContent || [])[index];\n      fn(fullUrl, sourceContent, index);\n    }\n  }\n  function resolve(code, codeUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n    if (code === null) {\n      var mapUrl = codeUrl;\n      var data = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      };\n      var readUrl = mapUrl;\n      read(readUrl, function (error, result) {\n        if (error) {\n          error.sourceMapData = data;\n          return callback(error);\n        }\n        data.map = String(result);\n        try {\n          data.map = parseMapToJSON(data.map, data);\n        } catch (error) {\n          return callback(error);\n        }\n        _resolveSources(data);\n      });\n    } else {\n      resolveSourceMap(code, codeUrl, read, function (error, mapData) {\n        if (error) {\n          return callback(error);\n        }\n        if (!mapData) {\n          return callback(null, null);\n        }\n        _resolveSources(mapData);\n      });\n    }\n    function _resolveSources(mapData) {\n      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {\n        if (error) {\n          return callback(error);\n        }\n        mapData.sourcesResolved = result.sourcesResolved;\n        mapData.sourcesContent = result.sourcesContent;\n        callback(null, mapData);\n      });\n    }\n  }\n  function resolveSync(code, codeUrl, read, options) {\n    var mapData;\n    if (code === null) {\n      var mapUrl = codeUrl;\n      mapData = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      };\n      mapData.map = readSync(read, mapUrl, mapData);\n      mapData.map = parseMapToJSON(mapData.map, mapData);\n    } else {\n      mapData = resolveSourceMapSync(code, codeUrl, read);\n      if (!mapData) {\n        return null;\n      }\n    }\n    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);\n    mapData.sourcesResolved = result.sourcesResolved;\n    mapData.sourcesContent = result.sourcesContent;\n    return mapData;\n  }\n  return {\n    resolveSourceMap: resolveSourceMap,\n    resolveSourceMapSync: resolveSourceMapSync,\n    resolveSources: resolveSources,\n    resolveSourcesSync: resolveSourcesSync,\n    resolve: resolve,\n    resolveSync: resolveSync,\n    parseMapToJSON: parseMapToJSON\n  };\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}