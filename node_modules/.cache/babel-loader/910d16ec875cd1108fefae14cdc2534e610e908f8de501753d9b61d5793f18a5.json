{"ast":null,"code":"'use strict';\n\nvar normalize = require('value-or-function');\nvar slice = Array.prototype.slice;\nfunction createResolver(config, options) {\n  // TODO: should the config object be validated?\n  config = config || {};\n  options = options || {};\n  var resolver = {\n    resolve: resolve\n  };\n\n  // Keep constants separately\n  var constants = {};\n  function resolveConstant(key) {\n    if (constants.hasOwnProperty(key)) {\n      return constants[key];\n    }\n    var definition = config[key];\n    // Ignore options that are not defined\n    if (!definition) {\n      return;\n    }\n    var option = options[key];\n    if (option != null) {\n      if (typeof option === 'function') {\n        return;\n      }\n      option = normalize.call(resolver, definition.type, option);\n      if (option != null) {\n        constants[key] = option;\n        return option;\n      }\n    }\n    var fallback = definition.default;\n    if (option == null && typeof fallback !== 'function') {\n      constants[key] = fallback;\n      return fallback;\n    }\n  }\n\n  // Keep requested keys to detect (and disallow) recursive resolution\n  var stack = [];\n  function resolve(key) {\n    var option = resolveConstant(key);\n    if (option != null) {\n      return option;\n    }\n    var definition = config[key];\n    // Ignore options that are not defined\n    if (!definition) {\n      return;\n    }\n    if (stack.indexOf(key) >= 0) {\n      throw new Error('Recursive resolution denied.');\n    }\n    option = options[key];\n    var fallback = definition.default;\n    var appliedArgs = slice.call(arguments, 1);\n    var args = [definition.type, option].concat(appliedArgs);\n    function toResolve() {\n      stack.push(key);\n      var option = normalize.apply(resolver, args);\n      if (option == null) {\n        option = fallback;\n        if (typeof option === 'function') {\n          option = option.apply(resolver, appliedArgs);\n        }\n      }\n      return option;\n    }\n    function onResolve() {\n      stack.pop();\n    }\n    return tryResolve(toResolve, onResolve);\n  }\n  return resolver;\n}\nfunction tryResolve(toResolve, onResolve) {\n  try {\n    return toResolve();\n  } finally {\n    onResolve();\n  }\n}\nmodule.exports = createResolver;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}