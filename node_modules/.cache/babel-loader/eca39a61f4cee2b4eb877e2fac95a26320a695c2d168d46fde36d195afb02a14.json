{"ast":null,"code":"'use strict';\n\nvar chokidar = require('chokidar');\nvar debounce = require('just-debounce');\nvar asyncDone = require('async-done');\nvar defaults = require('object.defaults/immutable');\nvar isNegatedGlob = require('is-negated-glob');\nvar anymatch = require('anymatch');\nvar normalize = require('normalize-path');\nvar defaultOpts = {\n  delay: 200,\n  events: ['add', 'change', 'unlink'],\n  ignored: [],\n  ignoreInitial: true,\n  queue: true\n};\nfunction listenerCount(ee, evtName) {\n  if (typeof ee.listenerCount === 'function') {\n    return ee.listenerCount(evtName);\n  }\n  return ee.listeners(evtName).length;\n}\nfunction hasErrorListener(ee) {\n  return listenerCount(ee, 'error') !== 0;\n}\nfunction exists(val) {\n  return val != null;\n}\nfunction watch(glob, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  var opt = defaults(options, defaultOpts);\n  if (!Array.isArray(opt.events)) {\n    opt.events = [opt.events];\n  }\n  if (Array.isArray(glob)) {\n    // We slice so we don't mutate the passed globs array\n    glob = glob.slice();\n  } else {\n    glob = [glob];\n  }\n  var queued = false;\n  var running = false;\n\n  // These use sparse arrays to keep track of the index in the\n  // original globs array\n  var positives = new Array(glob.length);\n  var negatives = new Array(glob.length);\n\n  // Reverse the glob here so we don't end up with a positive\n  // and negative glob in position 0 after a reverse\n  glob.reverse().forEach(sortGlobs);\n  function sortGlobs(globString, index) {\n    var result = isNegatedGlob(globString);\n    if (result.negated) {\n      negatives[index] = result.pattern;\n    } else {\n      positives[index] = result.pattern;\n    }\n  }\n  var toWatch = positives.filter(exists);\n  function joinCwd(glob) {\n    if (glob && opt.cwd) {\n      return normalize(opt.cwd + '/' + glob);\n    }\n    return glob;\n  }\n\n  // We only do add our custom `ignored` if there are some negative globs\n  // TODO: I'm not sure how to test this\n  if (negatives.some(exists)) {\n    var normalizedPositives = positives.map(joinCwd);\n    var normalizedNegatives = negatives.map(joinCwd);\n    var shouldBeIgnored = function shouldBeIgnored(path) {\n      var positiveMatch = anymatch(normalizedPositives, path, true);\n      var negativeMatch = anymatch(normalizedNegatives, path, true);\n      // If negativeMatch is -1, that means it was never negated\n      if (negativeMatch === -1) {\n        return false;\n      }\n\n      // If the negative is \"less than\" the positive, that means\n      // it came later in the glob array before we reversed them\n      return negativeMatch < positiveMatch;\n    };\n    opt.ignored = [].concat(opt.ignored, shouldBeIgnored);\n  }\n  var watcher = chokidar.watch(toWatch, opt);\n  function runComplete(err) {\n    running = false;\n    if (err && hasErrorListener(watcher)) {\n      watcher.emit('error', err);\n    }\n\n    // If we have a run queued, start onChange again\n    if (queued) {\n      queued = false;\n      onChange();\n    }\n  }\n  function onChange() {\n    if (running) {\n      if (opt.queue) {\n        queued = true;\n      }\n      return;\n    }\n    running = true;\n    asyncDone(cb, runComplete);\n  }\n  var fn;\n  if (typeof cb === 'function') {\n    fn = debounce(onChange, opt.delay);\n  }\n  function watchEvent(eventName) {\n    watcher.on(eventName, fn);\n  }\n  if (fn) {\n    opt.events.forEach(watchEvent);\n  }\n  return watcher;\n}\nmodule.exports = watch;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}