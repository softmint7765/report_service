{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits;\nvar glob = require('glob');\nvar extend = require('extend');\nvar Readable = require('readable-stream').Readable;\nvar globParent = require('glob-parent');\nvar toAbsoluteGlob = require('to-absolute-glob');\nvar removeTrailingSeparator = require('remove-trailing-separator');\nvar globErrMessage1 = 'File not found with singular glob: ';\nvar globErrMessage2 = ' (if this was purposeful, use `allowEmpty` option)';\nfunction getBasePath(ourGlob, opt) {\n  return globParent(toAbsoluteGlob(ourGlob, opt));\n}\nfunction globIsSingular(glob) {\n  var globSet = glob.minimatch.set;\n  if (globSet.length !== 1) {\n    return false;\n  }\n  return globSet[0].every(function isString(value) {\n    return typeof value === 'string';\n  });\n}\nfunction GlobStream(ourGlob, negatives, opt) {\n  if (!(this instanceof GlobStream)) {\n    return new GlobStream(ourGlob, negatives, opt);\n  }\n  var ourOpt = extend({}, opt);\n  Readable.call(this, {\n    objectMode: true,\n    highWaterMark: ourOpt.highWaterMark || 16\n  });\n\n  // Delete `highWaterMark` after inheriting from Readable\n  delete ourOpt.highWaterMark;\n  var self = this;\n  function resolveNegatives(negative) {\n    return toAbsoluteGlob(negative, ourOpt);\n  }\n  var ourNegatives = negatives.map(resolveNegatives);\n  ourOpt.ignore = ourNegatives;\n  var cwd = ourOpt.cwd;\n  var allowEmpty = ourOpt.allowEmpty || false;\n\n  // Extract base path from glob\n  var basePath = ourOpt.base || getBasePath(ourGlob, ourOpt);\n\n  // Remove path relativity to make globs make sense\n  ourGlob = toAbsoluteGlob(ourGlob, ourOpt);\n  // Delete `root` after all resolving done\n  delete ourOpt.root;\n  var globber = new glob.Glob(ourGlob, ourOpt);\n  this._globber = globber;\n  var found = false;\n  globber.on('match', function (filepath) {\n    found = true;\n    var obj = {\n      cwd: cwd,\n      base: basePath,\n      path: removeTrailingSeparator(filepath)\n    };\n    if (!self.push(obj)) {\n      globber.pause();\n    }\n  });\n  globber.once('end', function () {\n    if (allowEmpty !== true && !found && globIsSingular(globber)) {\n      var err = new Error(globErrMessage1 + ourGlob + globErrMessage2);\n      return self.destroy(err);\n    }\n    self.push(null);\n  });\n  function onError(err) {\n    self.destroy(err);\n  }\n  globber.once('error', onError);\n}\ninherits(GlobStream, Readable);\nGlobStream.prototype._read = function () {\n  this._globber.resume();\n};\nGlobStream.prototype.destroy = function (err) {\n  var self = this;\n  this._globber.abort();\n  process.nextTick(function () {\n    if (err) {\n      self.emit('error', err);\n    }\n    self.emit('close');\n  });\n};\nmodule.exports = GlobStream;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}