{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar fs = require('graceful-fs');\nvar nal = require('now-and-later');\nvar File = require('vinyl');\nvar convert = require('convert-source-map');\nvar removeBOM = require('remove-bom-buffer');\nvar appendBuffer = require('append-buffer');\nvar normalizePath = require('normalize-path');\nvar urlRegex = /^(https?|webpack(-[^:]+)?):\\/\\//;\nfunction isRemoteSource(source) {\n  return source.match(urlRegex);\n}\nfunction parse(data) {\n  try {\n    return JSON.parse(removeBOM(data));\n  } catch (err) {\n    // TODO: should this log a debug?\n  }\n}\nfunction loadSourceMap(file, state, callback) {\n  // Try to read inline source map\n  state.map = convert.fromSource(state.content);\n  if (state.map) {\n    state.map = state.map.toObject();\n    // Sources in map are relative to the source file\n    state.path = file.dirname;\n    state.content = convert.removeComments(state.content);\n    // Remove source map comment from source\n    file.contents = new Buffer(state.content, 'utf8');\n    return callback();\n  }\n\n  // Look for source map comment referencing a source map file\n  var mapComment = convert.mapFileCommentRegex.exec(state.content);\n  var mapFile;\n  if (mapComment) {\n    mapFile = path.resolve(file.dirname, mapComment[1] || mapComment[2]);\n    state.content = convert.removeMapFileComments(state.content);\n    // Remove source map comment from source\n    file.contents = new Buffer(state.content, 'utf8');\n  } else {\n    // If no comment try map file with same name as source file\n    mapFile = file.path + '.map';\n  }\n\n  // Sources in external map are relative to map file\n  state.path = path.dirname(mapFile);\n  fs.readFile(mapFile, onRead);\n  function onRead(err, data) {\n    if (err) {\n      return callback();\n    }\n    state.map = parse(data);\n    callback();\n  }\n}\n\n// Fix source paths and sourceContent for imported source map\nfunction fixImportedSourceMap(file, state, callback) {\n  if (!state.map) {\n    return callback();\n  }\n  state.map.sourcesContent = state.map.sourcesContent || [];\n  nal.map(state.map.sources, normalizeSourcesAndContent, callback);\n  function assignSourcesContent(sourceContent, idx) {\n    state.map.sourcesContent[idx] = sourceContent;\n  }\n  function normalizeSourcesAndContent(sourcePath, idx, cb) {\n    var sourceRoot = state.map.sourceRoot || '';\n    var sourceContent = state.map.sourcesContent[idx] || null;\n    if (isRemoteSource(sourcePath)) {\n      assignSourcesContent(sourceContent, idx);\n      return cb();\n    }\n    if (state.map.sourcesContent[idx]) {\n      return cb();\n    }\n    if (sourceRoot && isRemoteSource(sourceRoot)) {\n      assignSourcesContent(sourceContent, idx);\n      return cb();\n    }\n    var basePath = path.resolve(file.base, sourceRoot);\n    var absPath = path.resolve(state.path, sourceRoot, sourcePath);\n    var relPath = path.relative(basePath, absPath);\n    var unixRelPath = normalizePath(relPath);\n    state.map.sources[idx] = unixRelPath;\n    if (absPath !== file.path) {\n      // Load content from file async\n      return fs.readFile(absPath, onRead);\n    }\n\n    // If current file: use content\n    assignSourcesContent(state.content, idx);\n    cb();\n    function onRead(err, data) {\n      if (err) {\n        assignSourcesContent(null, idx);\n        return cb();\n      }\n      assignSourcesContent(removeBOM(data).toString('utf8'), idx);\n      cb();\n    }\n  }\n}\nfunction mapsLoaded(file, state, callback) {\n  if (!state.map) {\n    state.map = {\n      version: 3,\n      names: [],\n      mappings: '',\n      sources: [normalizePath(file.relative)],\n      sourcesContent: [state.content]\n    };\n  }\n  state.map.file = normalizePath(file.relative);\n  file.sourceMap = state.map;\n  callback();\n}\nfunction addSourceMaps(file, state, callback) {\n  var tasks = [loadSourceMap, fixImportedSourceMap, mapsLoaded];\n  function apply(fn, key, cb) {\n    fn(file, state, cb);\n  }\n  nal.mapSeries(tasks, apply, done);\n  function done() {\n    callback(null, file);\n  }\n}\n\n/* Write Helpers */\nfunction createSourceMapFile(opts) {\n  return new File({\n    cwd: opts.cwd,\n    base: opts.base,\n    path: opts.path,\n    contents: new Buffer(JSON.stringify(opts.content)),\n    stat: {\n      isFile: function isFile() {\n        return true;\n      },\n      isDirectory: function isDirectory() {\n        return false;\n      },\n      isBlockDevice: function isBlockDevice() {\n        return false;\n      },\n      isCharacterDevice: function isCharacterDevice() {\n        return false;\n      },\n      isSymbolicLink: function isSymbolicLink() {\n        return false;\n      },\n      isFIFO: function isFIFO() {\n        return false;\n      },\n      isSocket: function isSocket() {\n        return false;\n      }\n    }\n  });\n}\nvar needsMultiline = ['.css'];\nfunction getCommentOptions(extname) {\n  var opts = {\n    multiline: needsMultiline.indexOf(extname) !== -1\n  };\n  return opts;\n}\nfunction writeSourceMaps(file, destPath, callback) {\n  var sourceMapFile;\n  var commentOpts = getCommentOptions(file.extname);\n  var comment;\n  if (destPath == null) {\n    // Encode source map into comment\n    comment = convert.fromObject(file.sourceMap).toComment(commentOpts);\n  } else {\n    var mapFile = path.join(destPath, file.relative) + '.map';\n    var sourceMapPath = path.join(file.base, mapFile);\n\n    // Create new sourcemap File\n    sourceMapFile = createSourceMapFile({\n      cwd: file.cwd,\n      base: file.base,\n      path: sourceMapPath,\n      content: file.sourceMap\n    });\n    var sourcemapLocation = path.relative(file.dirname, sourceMapPath);\n    sourcemapLocation = normalizePath(sourcemapLocation);\n    comment = convert.generateMapFileComment(sourcemapLocation, commentOpts);\n  }\n\n  // Append source map comment\n  file.contents = appendBuffer(file.contents, comment);\n  callback(null, file, sourceMapFile);\n}\nmodule.exports = {\n  addSourceMaps: addSourceMaps,\n  writeSourceMaps: writeSourceMaps\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}